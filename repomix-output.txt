This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
examples/
  example1/
    main.go
go.mod
neoarch.go

================================================================
Files
================================================================

================
File: examples/example1/main.go
================
package main

import (
	"fmt"
	"log"

	"github.com/neo4j/neo4j-go-driver/v5/neo4j"
	. "github.com/wricardo/neoarch"
)

func main() {
	// Create a new design
	design := NewDesign("Example 1", "Something")

	// Create Persons
	user := design.Person("User", "Any internet user").
		External().
		Tag("person")

	developer := design.Person("Developer", "developer/employee").
		Tag("person").
		Tag("developer")

	// Person -> Person usage
	user.InteractsWith(developer, "Interacts with developer")

	// Create a System with nested containers/components
	someSystem := design.System("SomeSystem", "API system").
		// UsedBy(user, "Uses the system").
		Tag("system")

	api := someSystem.Container("API", "Backend API for Doxy").
		// UsedBy(user, "Uses the system").
		Tag("system")

	api.Component("GraphQL", "GraphQL API").
		UsedBy(user, "Uses the API").
		Tag("component").
		Tag("graphql")

	// Connect to Neo4j and save everything
	neo4jURI := "neo4j://localhost:7687" // Example connection URI
	username := "neo4j"
	password := "neo4jneo4j"

	driver, err := neo4j.NewDriver(neo4jURI, neo4j.BasicAuth(username, password, ""))
	if err != nil {
		log.Fatal("Failed to create driver:", err)
	}

	defer driver.Close()
	clearNeo4j(driver)

	// Push the design to Neo4j
	if err := design.SaveToNeo4j(driver); err != nil {
		log.Fatalf("Failed to save design: %v", err)
	} else {
		fmt.Println("Design saved successfully to Neo4j!")
	}
}

// clearNeo4j is a helper to wipe all nodes & relationships in the DB.
func clearNeo4j(driver neo4j.Driver) {
	session := driver.NewSession(neo4j.SessionConfig{DatabaseName: "neo4j"})
	defer session.Close()

	_, err := session.WriteTransaction(func(tx neo4j.Transaction) (any, error) {
		_, e := tx.Run("MATCH (n) DETACH DELETE n", nil)
		return nil, e
	})
	if err != nil {
		log.Fatalf("Failed to clear Neo4j: %v", err)
	} else {
		fmt.Println("Neo4j cleared successfully!")
	}
}

================
File: go.mod
================
module github.com/wricardo/neoarch

go 1.24.2

require github.com/neo4j/neo4j-go-driver/v5 v5.28.0

================
File: neoarch.go
================
package neoarch

import (
	"fmt"

	"github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

// -----------------------------------------------------------------------------
// Enumerations & Basic Types
// -----------------------------------------------------------------------------

// NodeType is an enum-like type for different C4 elements.
type NodeType string

const (
	NodeTypePerson    NodeType = "Person"
	NodeTypeSystem    NodeType = "System"
	NodeTypeContainer NodeType = "Container"
	NodeTypeComponent NodeType = "Component"
)

// RelationshipType is a type for naming relationships
type RelationshipType string

const (
	RelUses          RelationshipType = "USES"
	RelImpliedUse    RelationshipType = "IMPLIED_USE"
	RelBelongsTo     RelationshipType = "BELONGS_TO"
	RelInteractsWith RelationshipType = "INTERACTS_WITH"
)

// Relationship represents a direction from "start" to "end" with a type & description.
type Relationship struct {
	StartID     string
	EndID       string
	Type        RelationshipType
	Description string
}

type INode interface {
	GetID() string
}

// -----------------------------------------------------------------------------
// Core Node & Derived Types
// -----------------------------------------------------------------------------

// Node is the shared struct for all C4 elements.
type Node struct {
	ID          string   // Unique identifier (could be the "name")
	Name        string   // Display name
	Description string   // Brief description
	NodeType    NodeType // e.g. Person, System, Container, Component
	Tags        []string // Arbitrary tags
	External    bool     // For marking external nodes
	design      *Design  // Link back to the containing Design
}

// GetID returns the ID of the node.
func (n *Node) GetID() string {
	return n.ID
}

// Tag appends a tag to the Node.
func (n *Node) Tag(tag string) {
	n.Tags = append(n.Tags, tag)
}

// -----------------------------------------------------------------------------
// DSL Structures: Person, System, Container, Component
// Each is basically a wrapper around Node with chainable methods
// -----------------------------------------------------------------------------

// Person represents a "Person" node in C4.
type Person struct {
	*Node
	design *Design // Link back to the parent design
}

// InteractsWith creates a "USES" relationship from this person to another node.
func (p *Person) InteractsWith(other *Person, description string) *Person {
	p.design.addRelationship(p, other, RelInteractsWith, description)
	return p
}

// Person can also use “UsedBy” if you want to invert direction, but here we
// only define InteractsWith, as per your example usage.

// -----------------------------------------------------------------------------

// System represents a "System" node in C4.
type System struct {
	*Node
	design *Design // Link back to the parent design
}

func (s *System) ImpliedUseBy(p *Person, description string) *System {
	s.design.addRelationship(p, s, RelImpliedUse, description)
	return s
}

// UsedBy creates a "USES" relationship from the given person to this system.
func (s *System) UsedBy(p *Person, description string) *System {
	s.design.addRelationship(p, s, RelUses, description)
	return s
}

// Tag adds a tag (chainable).
func (s *System) Tag(t string) *System {
	s.Node.Tag(t)
	return s
}

// Container creates a new Container and (by convention) relates the system->container
// with "BELONGS_TO". You can adapt as needed.
func (s *System) Container(name, description string) *Container {
	container := &Container{
		Node: &Node{
			ID:          fmt.Sprintf("%s.cr_%s", s.ID, name), // For uniqueness
			Name:        name,
			Description: description,
			NodeType:    NodeTypeContainer,
			design:      s.design,
		},
		system: s,
	}
	s.design.nodes = append(s.design.nodes, container.Node)

	// We record that the container belongs to this system
	s.design.addRelationship(container, s, RelBelongsTo, "System contains Container")

	return container
}

// -----------------------------------------------------------------------------

// Container represents a "Container" node in C4.
type Container struct {
	*Node
	system *System // Link back to the parent system
}

// UsedBy creates a "USES" relationship from the given person to this container.
func (c *Container) UsedBy(p *Person, description string) *Container {
	c.design.addRelationship(p, c, RelUses, description)
	c.system.ImpliedUseBy(p, description) // Also relate container->person
	return c
}

func (c *Container) ImpliedUseBy(p *Person, description string) *Container {
	c.design.addRelationship(p, c, RelImpliedUse, description)
	c.system.ImpliedUseBy(p, description) // Also relate component->person
	return c
}

// Tag adds a tag (chainable).
func (c *Container) Tag(t string) *Container {
	c.Node.Tag(t)
	return c
}

// Component creates a new Component and relates container->component with BELONGS_TO.
func (c *Container) Component(name, description string) *Component {
	component := &Component{
		container: c,
		Node: &Node{
			ID:          fmt.Sprintf("%s.ct_%s", c.ID, name),
			Name:        name,
			Description: description,
			NodeType:    NodeTypeComponent,
			design:      c.design,
		},
	}
	c.design.nodes = append(c.design.nodes, component.Node)

	// We record that the component belongs to this container
	c.design.addRelationship(component, c, RelBelongsTo, "Container contains Component")

	return component
}

// -----------------------------------------------------------------------------

// Component represents a "Component" node in C4.
type Component struct {
	*Node
	container *Container
}

// UsedBy creates a "USES" relationship from the given person to this component.
func (c *Component) UsedBy(p *Person, description string) *Component {
	c.design.addRelationship(p, c, RelUses, description)
	c.container.ImpliedUseBy(p, description) // Also relate container->person
	return c
}

// Tag adds a tag (chainable).
func (c *Component) Tag(t string) *Component {
	c.Node.Tag(t)
	return c
}

// -----------------------------------------------------------------------------
// Design: the container for all nodes & relationships
// -----------------------------------------------------------------------------

// Design represents a C4 model
type Design struct {
	ID            string
	Name          string
	Description   string
	nodes         []*Node
	relationships []Relationship
}

// NewDesign creates a new C4 design
func NewDesign(name, description string) *Design {
	return &Design{
		ID:          "design_" + name,
		Name:        name,
		Description: description,
		nodes:       []*Node{},
	}
}

// Person constructs a Person node in this Design.
func (d *Design) Person(name, description string) *Person {
	p := &Person{
		Node: &Node{
			ID:          "person_" + name,
			Name:        name,
			Description: description,
			NodeType:    NodeTypePerson,
			design:      d,
		},
		design: d,
	}
	d.nodes = append(d.nodes, p.Node)
	return p
}

// System constructs a System node in this Design.
func (d *Design) System(name, description string) *System {
	s := &System{
		Node: &Node{
			ID:          "ss_" + name,
			Name:        name,
			Description: description,
			NodeType:    NodeTypeSystem,
			design:      d,
		},
		design: d,
	}
	d.nodes = append(d.nodes, s.Node)
	return s
}

// addRelationship is a helper to record relationships in the design.
func (d *Design) addRelationship(startID, endID INode, relType RelationshipType, desc string) {
	d.relationships = append(d.relationships, Relationship{
		StartID:     startID.GetID(),
		EndID:       endID.GetID(),
		Type:        relType,
		Description: desc,
	})
}

// SaveToNeo4j pushes the entire model to the Neo4j database
func (d *Design) SaveToNeo4j(driver neo4j.Driver) error {
	session := driver.NewSession(neo4j.SessionConfig{DatabaseName: "neo4j"})
	defer session.Close()

	_, err := session.WriteTransaction(func(tx neo4j.Transaction) (any, error) {
		// MERGE all nodes
		for _, node := range d.nodes {
			setStr := "n.name=$name, n.description=$desc, n.nodeType=$nodeType, n.tags=$tags"
			params := map[string]any{
				"id":       node.ID,
				"name":     node.Name,
				"desc":     node.Description,
				"nodeType": string(node.NodeType),
				"tags":     node.Tags,
			}
			for _, tag := range node.Tags {
				setStr += ", n.tag_" + tag + "=$tag_" + tag
				params["tag_"+tag] = tag
			}
			if node.External {
				setStr += ", n.external=$ext"
				params["ext"] = node.External
			}

			query := `
MERGE (n:` + string(node.NodeType) + ` { id: $id })
ON CREATE SET ` + setStr + `
ON MATCH SET  ` + setStr + `
`
			if _, e := tx.Run(query, params); e != nil {
				return nil, e
			}
		}

		// MERGE all relationships
		for _, rel := range d.relationships {
			query := fmt.Sprintf(`
MATCH (start { id: $startID })
MATCH (end { id: $endID })
MERGE (start)-[r:%s { description: $desc }]->(end)
`, rel.Type)

			params := map[string]any{
				"startID": rel.StartID,
				"endID":   rel.EndID,
				"desc":    rel.Description,
			}
			if _, e := tx.Run(query, params); e != nil {
				return nil, e
			}
		}
		return nil, nil
	})
	return err
}



================================================================
End of Codebase
================================================================
